# Οδηγίες και Περιγραφή του Project
## Περιγραφή
Αυτό το project υλοποιεί το πρόβλημα του «Μπαρ στο Μονοπάτι για τη Νεμέα», όπως περιγράφεται στη σχετική εργασία του μαθήματος Λειτουργικά Συστήματα (Κ22) του Τμήματος Πληροφορικής και Τηλεπικοινωνιών του Πανεπιστημίου Αθηνών.

Στόχος είναι να συντονιστούν διάφορες ανεξάρτητες διεργασίες (visitor, receptionist και monitor) οι οποίες συνεργάζονται μέσω shared memory και semaphores, για να εξυπηρετήσουν πελάτες σε ένα υπαίθριο μπαρ. Οι πελάτες έρχονται, καταλαμβάνουν καρέκλες σε τραπέζια, κάνουν παραγγελίες, και αποχωρούν, ενώ ένας υπεύθυνος (receptionist) παίρνει και εκτελεί τις παραγγελίες. Επιπλέον, ένα πρόγραμμα monitor μπορεί ανά πάσα στιγμή να παρουσιάσει την τρέχουσα κατάσταση του μπαρ.

## Κύρια Σημεία του Προβλήματος
* Υπάρχουν 3 τραπέζια με 4 καρέκλες το καθένα.
* Έως 4 πελάτες μπορούν να καθίσουν στο ίδιο τραπέζι διαδοχικά.
* Αν ένα τραπέζι γεμίσει, δεν μπορεί να δεχτεί νέους επισκέπτες μέχρι να αδειάσει εντελώς.
* Οι πελάτες παραγγέλνουν νερό ή κρασί (υποχρεωτικά ένα από τα δύο, πιθανώς και τα δύο) και προαιρετικά τυρί ή/και σαλάτα.
* Μετά την παραγγελία, οι πελάτες κάθονται, τρώνε/πίνουν και συζητούν για ένα τυχαίο διάστημα και στη συνέχεια αποχωρούν.
* Αν δεν υπάρχει διαθέσιμη καρέκλα, ο επισκέπτης περιμένει μέχρι να αδειάσει πλήρως ένα τραπέζι.
* Τα στατιστικά (π.χ. συνολικοί επισκέπτες, μέσος χρόνος αναμονής/παραμονής, σύνολο παραγγελιών) αποθηκεύονται σε μια περιοχή shared memory.
* Η επικοινωνία και ο συγχρονισμός γίνονται μέσω POSIX semaphores και μεταβλητών σε shared memory.
* Ένα πρόγραμμα monitor μπορεί να εκτελεστεί οποιαδήποτε στιγμή και να εμφανίσει την κατάσταση του μπαρ.
* Στο τέλος της ημέρας (όταν όλοι οι επισκέπτες έχουν εξυπηρετηθεί), ο receptionist τυπώνει τα στατιστικά και απελευθερώνει τους πόρους (shared memory, semaphores).
## Εκτέλεση
Το project αποτελείται από πολλά εκτελέσιμα προγράμματα:

1. initializeSM: Δημιουργεί και αρχικοποιεί το shared memory segment και τους semaphores.
    * Χρήση: `./initializeSM -p pipe_write_fd`
    * Αυτό το πρόγραμμα δημιουργεί το shmid και το γράφει μέσω ενός pipe, ώστε η κύρια διεργασία να το λάβει.

2. receptionist: Ο υπεύθυνος του μπαρ, παίρνει παραγγελίες από τους πελάτες.
    * Χρήση: `./receptionist -d ordertime -s shmid`
    * ordertime: Μέγιστη διάρκεια επεξεργασίας παραγγελίας
    * shmid: To ID του shared memory segment

3. visitor: Αναπαριστά έναν πελάτη.
    * Χρήση: `./visitor -id idVis -d resttime -s shmid`
    * idVis: (Προαιρετικό): Αναγνωριστικό του επισκέπτη. Αν δεν δοθεί, το πρόγραμμα δημιουργεί τυχαίο ID.
    * resttime: Μέγιστος χρόνος παραμονής στο τραπέζι
    * shmid: To ID του shared memory segment

4. monitor: Παρουσιάζει την τρέχουσα κατάσταση του μπαρ.
    * Χρήση: `./monitor -s shmid`
    * Εμφανίζει τον αριθμό επισκεπτών, τον συνολικό χρόνο παραμονής, χρόνους αναμονής, καθώς και την κατάσταση των τραπεζιών.

5. end_day: Θέτει τη σημαία τερματισμού ώστε ο receptionist να εκτυπώσει τα στατιστικά και να καθαρίσει τους πόρους.
    * Χρήση: `./end_day -s shmid`
6. main: Ένα παράδειγμα κεντρικού προγράμματος που:
    * Εκκινεί το initializeSM για να πάρει shmid.
    * Εκκινεί τον receptionist.
    * Εκκινεί τυχαίο αριθμό επισκεπτών σε τυχαία χρονικά διαστήματα.
    * Περιμένει τη λήξη όλων των visitors.
    * Θέτει τη σημαία τερματισμού και τερματίζει.

## Μεταγλώττιση
Χρησιμοποιήστε το Makefile που παρέχεται:
```
make all
```
Τα εκτελέσιμα που παράγονται είναι: `main`, `visitor`, `receptionist`, `monitor`, `initializeSM`, `end_day`.

## Εκτέλεση Παραδείγματος 1
1. Εκκινήστε το main:
    ```
    ./main -o 5.0 -r 5.0
    ```
    * Δημιουργεί shared memory.
    * Εκκινεί τον receptionist.
    * Εκκινεί τυχαίο αριθμό visitors.
    * Περιμένει την ολοκλήρωσή τους.

2. Μπορείτε σε άλλο τερματικό να εκτελέσετε:
    ```
    ./monitor -s <shmid>
    ```
    για να δείτε την τρέχουσα κατάσταση του μπαρ οποιαδήποτε στιγμή.

3. Μετά την ολοκλήρωση, τα στατιστικά καταγράφονται σε αρχείο events.log.

## Εκτέλεση Παραδείγματος 2 (Χωρίς χρήση του main):
1. initializeSM: Δημιουργεί το shared memory segment και εμφανίζει το shmid.
    ```
    ./initializeSM -p 1
    ```
2. receptionist: Εκκινεί τον υπεύθυνο.
    ```    
    ./receptionist -d 5.0 -s <shmid>
    ```

3. visitors: Εκκινήστε όσους επισκέπτες θέλετε.
    ```
    ./visitor -id 1 -d 5.0 -s <shmid>
    ./visitor -id 2 -d 4.0 -s <shmid>
    # ...
    ```
4. monitor (προαιρετικά): Παρακολούθηση κατάστασης.
    ```
    ./monitor -s <shmid>
    ```
5. end_day: Τερματίζει τη λειτουργία.
    ```
    ./end_day -s <shmid>
    ```

## Logging
Όλες οι σημαντικές ενέργειες (αφίξεις επισκεπτών, παραγγελίες, κατάσταση τραπεζιών, στατιστικά) καταγράφονται σε ένα αρχείο events.log. Χρησιμοποιούμε μια κλάση Logger για ατομικές εγγραφές και εύκολη προσθήκη μηνυμάτων.

## Απελευθέρωση Πόρων
Στο τέλος της εκτέλεσης:
* Ο receptionist τυπώνει τα στατιστικά.
* Το shared memory και τα semaphores καταστρέφονται και απελευθερώνονται.
* Αν χρησιμοποιήσετε το ./end_day -s shmid, θα θέσει τη σημαία για να τερματίσει ο receptionist ομαλά.


## Συνολική Προσέγγιση με Σημαφόρους
Το πρόβλημα ζητά τον συγχρονισμό πολλών ανεξάρτητων διεργασιών (visitors) που προσπαθούν να καθίσουν, να κάνουν παραγγελίες και να αποχωρήσουν από ένα μπαρ, το οποίο εξυπηρετείται από έναν μόνο υπεύθυνο (receptionist).

Οι βασικοί στόχοι συγχρονισμού είναι:
* Να μην δημιουργηθεί λιμός (starvation).
* Να υπάρχει ασφάλεια στη χρήση του κοινού χώρου (τραπέζια/καρέκλες).
* Να εξυπηρετούνται οι επισκέπτες με τη σειρά που φτάνουν και να λαμβάνουν τις παραγγελίες τους ένας-ένας από τον receptionist.
* Να διασφαλίζεται ότι μόλις τραπέζια «κλειδωθούν» (επειδή κάποιος έφυγε πριν γεμίσει ή αδειάσει πλήρως το τραπέζι), δεν μπορούν να δεχτούν νέους επισκέπτες έως ότου αδειάσουν τελείως.

Για να επιτευχθούν τα παραπάνω, χρησιμοποιούνται πολλαπλοί σημαφόροι:

### 1. Σημαφόροι Ελέγχου Παραγγελιών (`sem_order`, `sem_order_guard`)
* `sem_order`:
    
    Χρησιμοποιείται για να «σηματοδοτεί» στον receptionist ότι υπάρχει κάποιος επισκέπτης έτοιμος να δώσει παραγγελία.
    * Όταν ένας visitor είναι έτοιμος, κάνει sem_post(&sem_order), ξεκλειδώνοντας ουσιαστικά τον receptionist να τον εξυπηρετήσει.
    * Ο receptionist κάνει sem_wait(&sem_order) περιμένοντας έως ότου εμφανιστεί κάποιος επισκέπτης προς εξυπηρέτηση. Αν δεν υπάρχουν επισκέπτες, ο receptionist μπλοκάρει.
* `sem_order_guard`:

    Λειτουργεί ως «φύλακας» για να αποφευχθεί η ταυτόχρονη είσοδος πολλών επισκεπτών σε κατάσταση «παραγγελίας».
    * Πριν ένας visitor σημάνει στον receptionist ότι είναι έτοιμος (με sem_post(&sem_order)), πρέπει να πάρει το “ΟΚ” από το sem_order_guard (δηλαδή κάνει sem_wait(&sem_order_guard)).
    * Μόλις εξυπηρετηθεί ένας επισκέπτης, ο receptionist κάνει sem_post(&sem_order_guard), επιτρέποντας σε επόμενο επισκέπτη να δηλώσει ετοιμότητα παραγγελίας.

Με αυτόν τον συνδυασμό (sem_order και sem_order_guard) εξασφαλίζεται ότι ο receptionist εξυπηρετεί έναν πελάτη κάθε φορά και δεν «συνωστίζονται» πολλοί επισκέπτες να δώσουν παραγγελία ταυτόχρονα.

### 2. Σημαφόρος για τις Καρέκλες γενικά (`available_seats`)
* `available_seats`:
    Ελέγχει το σύνολο των διαθέσιμων καρεκλών στο μπαρ (σε όλα τα τραπέζια μαζί). Αν δεν υπάρχουν διαθέσιμες καρέκλες, ένας επισκέπτης που φτάνει στο μπαρ πρέπει να περιμένει.
    * Η αρχική τιμή του είναι NUM_TABLES * NUM_CHAIRS_PER_TABLE, δηλαδή το συνολικό πλήθος των καρεκλών που έχει το μπαρ.
    * Κάθε φορά που ένας visitor προσπαθεί να καθίσει, κάνει sem_wait(&available_seats). Αν δεν υπάρχει διαθέσιμη καρέκλα, μπλοκάρει μέχρι να ελευθερωθεί μία.
    * Όταν ένας visitor αποχωρεί, κάνει sem_post(&available_seats), αυξάνοντας τον αριθμό των διαθέσιμων καρεκλών.

Με τον τρόπο αυτό, διασφαλίζεται ότι δεν θα προσπαθήσουν να καθίσουν περισσότεροι επισκέπτες από όσες καρέκλες υπάρχουν συνολικά.

### 3. Σημαφόροι ανά Τραπέζι (`sem_table`)
* Κάθε τραπέζι έχει το δικό του σημαφόρο, `sem_table`, που έχει αρχική τιμή NUM_CHAIRS_PER_TABLE.
    * Όταν ένας επισκέπτης προσπαθεί να καθίσει σε συγκεκριμένο τραπέζι, κάνει sem_wait(&sem_table) ώστε να δεσμεύσει μία καρέκλα αυτού του τραπεζιού.
    * Αν όλες οι καρέκλες ενός τραπεζιού είναι κατειλημμένες, οποιοσδήποτε προσπαθήσει να κάτσει σ’ αυτό το τραπέζι θα μπλοκάρει μέχρι να αδειάσει μία καρέκλα.
    
Σε συνδυασμό με το available_seats, το sem_table εξασφαλίζει τον έλεγχο τόσο σε επίπεδο συνολικού αριθμού καρεκλών (global) όσο και σε επίπεδο επιμέρους τραπεζιού (local).

### 4. Μηχανισμός "Κλειδώματος" Τραπεζιών (`is_locked`)
Στο πρόβλημα υπάρχει η απαίτηση: Αν ένα τραπέζι γεμίσει (4 επισκέπτες) και κάποιος αποχωρήσει προτού αδειάσει τελείως το τραπέζι, το τραπέζι γίνεται "κλειδωμένο" (is_locked = true) και δεν δέχεται νέους επισκέπτες. Αυτό υλοποιείται όχι μόνο με σημαφόρους, αλλά και με μεταβλητές κατάστασης (is_locked) και πρόσθετους ελέγχους σε συνδυασμό με mutex:
* Οι visitors πριν καθίσουν ελέγχουν αν το τραπέζι είναι is_locked = false και υπάρχει διαθέσιμη καρέκλα (sem_table > 0).
* Αν το τραπέζι είναι κλειδωμένο, ο visitor δεν κάθεται και περιμένει μέχρι το τραπέζι να αδειάσει πλήρως και να ξεκλειδώσει.

Η λογική αυτή διασφαλίζει ότι δεν θα έχουμε ένα τραπέζι που μονίμως δέχεται και χάνει επισκέπτες χωρίς να αδειάσει ποτέ, οδηγώντας σε πιθανό λιμό.

### 5. Mutexes για Προστασία Κοινόχρηστων Δομών Δεδομένων
Εκτός από τους σημαφόρους που ελέγχουν την αλληλουχία και τη διαθεσιμότητα πόρων, χρησιμοποιούνται και mutexes για την προστασία κοινόχρηστων μεταβλητών στη shared memory (π.χ. στατιστικά, δείκτης τραπεζιού, is_locked). Οι σημαφόροι ρυθμίζουν την πρόσβαση σε πόρους (καρέκλες, σειρά παραγγελίας), ενώ τα mutex διασφαλίζουν τη συνεπή ενημέρωση δεδομένων στη μνήμη.

#### Έτσι, το σύστημα λειτουργεί χωρίς να εμφανίζονται συνθήκες αδιεξόδου (deadlock) ή αθέμιτου αποκλεισμού (starvation), ενώ τα στατιστικά ενημερώνονται με ασφάλεια.